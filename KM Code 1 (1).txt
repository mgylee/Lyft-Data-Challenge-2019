
#reads in driver_ids data
driver_ids <- read.csv("driver_ids.csv")

#reads in ride data
ride_ids <- read.csv("ride_ids.csv")

#reads in timestamps data
ride_timestamps <- read.csv("ride_timestamps.csv")

#separates the event timestamps in ride_timestamps into individual columns
ride_timestamps_mod <-spread(ride_timestamps,event,timestamp)

lyft_data <- full_join (ride_ids, ride_timestamps_mod)

lyft_data <-full_join(lyft_data, driver_ids)

lyft_data[,c("driver_id")] <- as.factor(lyft_data$driver_id)

#rearranges events to be in order
lyft_data <- lyft_data[c(2,1,3:5,10,6,7,9,8)]

#changes the event times columns to POSIX datatype
for(i in 6:10){
  
 lyft_data[,i] <- as.POSIXct(lyft_data[,i],format="%Y-%m-%d %H:%M:%S", tz="PST8PDT")

}

#recalculates the duration for rides that are missing that data
no_duration <- with(lyft_data,is.na(ride_duration)==TRUE)
lyft_data[no_duration,c("ride_duration")] <- lyft_data[no_duration,c("dropped_off_at")] - lyft_data[no_duration,c("picked_up_at")]

#shows summary of data
summary(lyft_data)

#calculates a summary of ride distance data omitting invalid data
summary(lyft_data[which(lyft_data[,c("ride_distance")]>0),c("ride_distance")])

#calculates the price of ride
#function takes in a list from the dataframe
calclyft <- function(ride){
  
  #changes distance from being in meters to miles
  distance <- as.numeric(ride["ride_distance"])/1609.34
  
  #changes duration of ride from seconds to minutes
  duration <- as.numeric(ride["ride_duration"])/60
  
  #(base + miles*1.15 + duration*0.22 + service fee)*prime time percentage
  price <- (2 + distance*1.15 + duration*0.22 + 1.75)*(1+as.numeric(ride["ride_prime_time"])/100)
    
  #if less than 5, return 5
  if(price<5){
    price=5
  }
  
  #if greater than 400, return 400
  if(price>400){
    price=400
  }
  
  return (price)
}

#defines a vector to hold driver revenues
driver_rev <- numeric()
num_rides <- numeric()

#pulls rides for each driver
for(i in 1:length(levels(driver_ids[,1]))){
  
  #data frame of each driver's rides
  driver_rides <- ride_ids[with(ride_ids,driver_id==levels(driver_ids[,1])[i]),]
  
  #eliminates rides with invalid distances
  driver_rides <- driver_rides[with(driver_rides,ride_distance>0),]
  
  #defines a total revenue for driver
  if(nrow(driver_rides)>0)
    rev <- sum(apply(driver_rides, 1, calclyft))
  else
    rev=0
  
  #adds to vector
  driver_rev[i]<-rev
  num_rides[i]<-nrow(driver_rides)

}

driver_ids <- cbind(driver_ids,"Revenue"=as.numeric(driver_rev),"Total Rides"=as.numeric(num_rides))

mean_rev <- mean(driver_ids$Revenue)

# Start Michelle's code

#Answer for 2b
# Determine driver_lifetimes
driver_lifetimes <- lyft_data %>%  
   select(driver_id:ride_prime_time, -(requested_at:picked_up_at), dropped_off_at) %>%
   group_by(driver_id) %>%
   arrange(dropped_off_at) %>%
   slice(n()) %>%
   mutate(driver_lifetime = as.Date(dropped_off_at) - as.Date(driver_onboard_date)) %>%
   mutate(driver_lifetime=replace(driver_lifetime, is.na(driver_lifetime), 0)) %>%
   select(driver_id, driver_onboard_date, dropped_off_at, driver_lifetime)

# Calculate average driver lifetime
mean(driver_lifetimes$driver_lifetime)

# Total number of rides in a lifetime
num_rides <- lyft_data %>%
    group_by(driver_id) %>%
    summarise(n = n_distinct(ride_id))

# Q2b dataframe for the graph
qtwob_graph <- left_join(driver_lifetimes, num_rides) %>%
   mutate(n=replace(n, is.na(n), 0))
head(test6)

# Q2b scatter plot
qtwob_graph %>%
  filter(driver_lifetime > 0 %in% n) %>%
  ggplot(aes(x=driver_lifetime, y=n)) + 
     geom_point() +
     xlab("Driver Lifetime") + 
     ylab("Number of Rides in a Lifetime") +
     ylim(c(0,800))

# Percent of riders likely to drive frequently past 27 days.
twenty_seven_days <- test6 %>%
   filter(driver_lifetime > 27) %>%
   nrow()
freq_drivers <- test6 %>%
   filter(driver_lifetime > 27, n>100) %>%
   nrow()
freq_drivers/twenty_seven_days

#Answer for 2c
# scatter plot of wait time vs ride length
ggplot(lyft_data, aes(x = (arrived_at - accepted_at)/60,
                  y = (dropped_off_at - accepted_at)/60)) + 
       geom_point() +
       xlab("Wait Time") +
       ylab("Ride Length") +
       xlim(c(0, 40)) + 
       ylim(c(0,150))

#End Michelle's Code

mean_lifetime<- mean(as.numeric((driver_data$driver_lifetime)))

averagelv <- mean_rev/mean_lifetime

mean_rides_pd <- mean(driver_ids$'Total Rides')/mean_lifetime

by_hour <- as.factor(format(lyft_data$requested_at, format="%H"))

hr_freq <- fct_count(by_hour)

by_hour <- data.frame(by_hour,lyft_data$ride_prime_time)
colnames(by_hour) <- c("Hour", "Prime Time")

by_hour <- drop_na(by_hour)

hourly_ride_freq <- ggplot(hr_freq[1:24,],aes(x=f,y=n),na.rm=TRUE)+geom_bar(stat="identity")

count(lyft_data, ride_prime_time)

by_hour[,3]<-with(by_hour,by_hour[,2]>0)

by_hour_prime <- count(by_hour,Hour,V3)

ggplot(by_hour_prime, aes(x = Hour, y = n, fill = V3)) +     geom_bar(stat = "identity") + xlab("\nHour") +    ylab("Number of Rides\n") + guides() + scale_fill_discrete(name = "Primetime Status",
labels = c("Not Prime", "Prime")) + theme_bw()
